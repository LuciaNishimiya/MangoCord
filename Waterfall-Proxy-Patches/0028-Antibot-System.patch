From 086231f86b1e31c3915679124c5b358dd406f2c7 Mon Sep 17 00:00:00 2001
From: LinsaFTW <25271111+linsaftw@users.noreply.github.com>
Date: Fri, 4 Mar 2022 13:35:53 -0300
Subject: [PATCH] Antibot System


diff --git a/mangcord/pom.xml b/mangcord/pom.xml
index 20edd900..95bdf348 100644
--- a/mangcord/pom.xml
+++ b/mangcord/pom.xml
@@ -30,6 +30,16 @@
             <version>${project.version}</version>
             <scope>compile</scope>
         </dependency>
+        <dependency>
+            <groupId>com.maxmind.db</groupId>
+            <artifactId>maxmind-db</artifactId>
+            <version>2.0.0</version>
+        </dependency>
+        <dependency>
+            <groupId>io.netty</groupId>
+            <artifactId>netty-handler</artifactId>
+            <scope>compile</scope>
+        </dependency>
     </dependencies>
 
     <build>
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/MangoCord.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/MangoCord.java
index 676ba95b..677b4a8e 100644
--- a/mangcord/src/main/java/dev/lucianishimiya/mangcord/MangoCord.java
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/MangoCord.java
@@ -1,8 +1,16 @@
 package dev.lucianishimiya.mangcord;
 
+import java.io.IOException;
 import java.util.Collection;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import dev.lucianishimiya.mangcord.antibot.AddressDataManager;
+import dev.lucianishimiya.mangcord.antibot.CheckManager;
+import dev.lucianishimiya.mangcord.antibot.LoggerWrapper;
+import dev.lucianishimiya.mangcord.antibot.StatsData;
 import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
 import dev.lucianishimiya.mangcord.configuration.MessagesConfiguration;
 import dev.lucianishimiya.mangcord.configuration.ModulesConfiguration;
@@ -13,8 +21,13 @@ import net.md_5.bungee.config.YamlConfiguration;
 public class MangoCord {
     @Getter
     private static MangoCord instance;
+    private static Runtime runtime;
 
     public static void initialize(final Logger logger, final Collection<String> whitelistedAddresses) {
+        if (MangoCord.runtime == null) {
+            MangoCord.runtime = Runtime.getRuntime();
+        }
+
         if (MangoCord.instance == null) {
             MangoCord.instance = new MangoCord();
         }
@@ -31,6 +44,16 @@ public class MangoCord {
     @Getter
     private MessagesConfiguration messagesConfiguration;
 
+    // MangoCord - Antibot System
+    @Getter
+    private AddressDataManager addressDataManager;
+    @Getter
+    private CheckManager checkManager;
+    @Getter
+    private StatsData statsData;
+    @Getter
+    private LoggerWrapper loggerWrapper;
+
     public void reload(final Logger logger, final Collection<String> whitelistedAddresses) {
         final ConfigurationProvider configurationProvider = ConfigurationProvider.getProvider(YamlConfiguration.class);
         
@@ -39,5 +62,106 @@ public class MangoCord {
         // MangoCord - Module System
         this.modulesConfiguration = new ModulesConfiguration(configurationProvider);
         this.messagesConfiguration = new MessagesConfiguration(logger, configurationProvider);
+
+        // MangoCord - Antibot System
+        if (checkManager != null) checkManager.unload();
+        this.loggerWrapper = new LoggerWrapper(Logger.getLogger("BungeeCord"));
+        this.addressDataManager = new AddressDataManager();
+        this.checkManager = new CheckManager(addressDataManager, mangoCordConfiguration);
+        this.statsData = new StatsData();
+
+        // Initialize antibot firewall ipset
+        if (mangoCordConfiguration.isAntibotFirewallIpset()) {
+            runLinuxCommand("apt install iptables -y"); // Install iptables
+            runLinuxCommand("apt install ipset -y"); // Install ipset
+            runLinuxCommand("ipset destroy mangcord-firewall"); // Delete old MangoCord set
+            runLinuxCommand("ipset create mangcord-firewall hash:ip timeout 60"); // Create new MangoCord set
+            runLinuxCommand("iptables -I INPUT -m set --match-set mangcord-firewall src -j DROP"); // Create iptables rule to DROP
+
+            // Thread to run queued firewall linux commands
+            new Thread(() -> {
+                MangoCord mangoCord = MangoCord.getInstance();
+
+                while (!mangoCord.isShuttingDown()) {
+                    mangoCord.runQueuedLinuxCommands();
+
+                    try {
+                        Thread.sleep(1000);
+                    } catch (InterruptedException e) {
+                        // Ignore
+                    }
+                }
+            }).start();
+        }
+    }
+
+    private boolean shutdown = false;
+
+    public boolean isShuttingDown() {
+        return shutdown;
+    }
+
+    public void shutdown() {
+        this.shutdown = true;
+    }
+
+    /**
+     * Utility to run a Linux commands for iptables.
+     * @param command
+     */
+    public void runLinuxCommand(String command) {
+        try {
+            runtime.exec("/bin/sh -c '" + command + "'");
+        } catch (IOException e) {
+            /*
+             * Windows throws exception.
+             */
+        }
+    }
+
+    // Commands to execute in the queue
+    private Collection<String> commandQueue = ConcurrentHashMap.newKeySet();
+
+    // Boolean for when the commands are processing
+    private boolean processing = false;
+
+    /**
+     * Add command to the linux command queue
+     * @param command
+     */
+    public void queueLinuxCommand(String command) {
+        commandQueue.add(command);
+    }
+
+    /**
+     * Run the queued linux commands
+     */
+    public void runQueuedLinuxCommands() {
+        if (!commandQueue.isEmpty() && !processing) {
+            processing = true;
+
+            try {
+                Iterator<String> iterator = commandQueue.iterator();
+                StringBuilder commands = new StringBuilder();
+                int ranCommands = 0;
+
+                while (iterator.hasNext()) {
+                    String command = iterator.next();
+
+                    if (ranCommands++ > 0) {
+                        commands.append(" && ");
+                    }
+
+                    commands.append(command);
+                    iterator.remove();
+                }
+
+                runLinuxCommand(commands.toString());
+
+                getLoggerWrapper().log(Level.INFO, "Blacklisted " + ranCommands + " ips from the kernel with IPSet");
+            } finally {
+                processing = false;
+            }
+        }
     }
 }
\ No newline at end of file
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/AccountsCheck.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/AccountsCheck.java
new file mode 100644
index 00000000..5cd9782a
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/AccountsCheck.java
@@ -0,0 +1,48 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.net.SocketAddress;
+import java.util.Collection;
+import java.util.logging.Level;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+
+public class AccountsCheck {
+    private MangoCordConfiguration config;
+    private LoggerWrapper logger;
+    private AddressDataManager addressDataManager;
+
+    public AccountsCheck(final AddressDataManager addressDataManager) {
+        this.config = MangoCord.getInstance().getMangoCordConfiguration();
+        this.logger = MangoCord.getInstance().getLoggerWrapper();
+        this.addressDataManager = addressDataManager;
+    }
+
+    public boolean check(final SocketAddress remoteAddress, final String nickname) {
+        if (config.getAntibotAccountsWhitelist().contains(nickname)) {
+            return false;
+        }
+
+        if (config.isAntibotAccountsEnabled()) {
+            final AddressData addressData = addressDataManager.getAddressData(remoteAddress);
+            final Collection<String> nicknames = addressData.getNicknames();
+
+            if (nicknames.size() > config.getAntibotAccountsLimit()) {
+                nicknames.remove(nickname);
+
+                if ( config.isAntibotAccountsLog() )
+                {
+                    logger.log( Level.INFO, "[Mangocord] [{0}] has too many accounts", remoteAddress );
+                }
+
+                if (config.isAntibotAccountsFirewall()) {
+                    addressData.firewall("Too many accounts");
+                }
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/AddressData.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/AddressData.java
new file mode 100644
index 00000000..7aa15796
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/AddressData.java
@@ -0,0 +1,170 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.logging.Level;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+
+public class AddressData {
+    private MangoCordConfiguration config;
+    private StatsData statsData;
+    private Collection<String> nicknames = null;
+    private final String hostString;
+    private String lastNickname = "";
+    private String country = null;
+    private String firewallReason = null;
+    private long lastPing = 0;
+    private long penultimateConnection = 0;
+    private long lastConnection = 0;
+    private long lastFirewall = 0;
+    private int pingsSecond = 0;
+    private int totalPings = 0;
+    private int connectionsSecond = 0;
+    private int totalConnections = 0;
+
+    public AddressData(final String hostString) {
+        this.config = MangoCord.getInstance().getMangoCordConfiguration();
+        this.statsData = MangoCord.getInstance().getStatsData();
+        this.hostString = hostString;
+    }
+
+    public Collection<String> getNicknames() {
+        if (nicknames == null) nicknames = new HashSet<>();
+
+        return nicknames;
+    }
+
+    public String getLastNickname() {
+        return lastNickname;
+    }
+
+    public void addNickname(final String nickname) {
+        if (nicknames == null) nicknames = new HashSet<>();
+
+        if (!lastNickname.equals(nickname)) {
+            this.lastNickname = nickname;
+            this.totalConnections = 1;
+        }
+
+        this.nicknames.add(nickname);
+    }
+
+    public long getPenultimateConnection() {
+        return penultimateConnection;
+    }
+
+    public long getTimeSincePenultimateConnection() {
+        return System.currentTimeMillis() - penultimateConnection;
+    }
+
+    public long getLastConnection() {
+        return lastConnection;
+    }
+
+    public long getTimeSinceLastConnection() {
+        return System.currentTimeMillis() - lastConnection;
+    }
+
+    private void updatePingsSecond() {
+        if (System.currentTimeMillis() - lastPing >= 1000) {
+            pingsSecond = 0;
+        }
+    }
+
+    public int getPingsSecond() {
+        updatePingsSecond();
+        return pingsSecond;
+    }
+
+    public void addPing() {
+        statsData.addPing();
+        updatePingsSecond();
+        lastPing = System.currentTimeMillis();
+        pingsSecond++;
+        totalPings++;
+    }
+
+    public int getTotalPings() {
+        return totalPings;
+    }
+
+    private void updateConnectionsSecond() {
+        if (System.currentTimeMillis() - lastConnection >= 1000) {
+            connectionsSecond = 0;
+        }
+    }
+
+    public int getConnectionsSecond() {
+        updateConnectionsSecond();
+        return connectionsSecond;
+    }
+
+    public void addConnection() {
+        final long currentTime = System.currentTimeMillis();
+
+        statsData.addConnection();
+        updateConnectionsSecond();
+        penultimateConnection = lastConnection == 0 ? currentTime : lastConnection;
+        lastConnection = currentTime;
+        connectionsSecond++;
+        totalConnections++;
+    }
+
+    public int getTotalConnections() {
+        return totalConnections;
+    }
+
+    public String getHostString() {
+        return hostString;
+    }
+
+    public boolean isFirewalled() {
+        return System.currentTimeMillis() - lastFirewall < config
+                .getAntibotFirewallExpire() * 1000;
+    }
+
+    public void firewall(String reason) {
+        if (!MangoCord.getInstance().getMangoCordConfiguration().getAntibotFirewallWhitelist().contains(hostString)) {
+            this.lastFirewall = System.currentTimeMillis();
+            this.firewallReason = reason;
+
+            if (MangoCord.getInstance().getMangoCordConfiguration().isAntibotFirewallLog()) {
+                MangoCord.getInstance().getLoggerWrapper().log( Level.INFO, "[Mangocord] [{0}] was firewalled because of " + reason, hostString );
+            }
+
+            // Queue the firewall as a ipset linux command
+            MangoCord.getInstance().queueLinuxCommand("ipset add mangcord-firewall " + hostString);
+        }
+    }
+
+    public void unfirewall() {
+        this.lastFirewall = 0;
+        this.firewallReason = null;
+    }
+
+    public String getFirewallReason() {
+        if (isFirewalled()) {
+            return firewallReason;
+        }
+
+        return null;
+    }
+
+    public void setTotalConnections(final int totalConnections) {
+        this.totalConnections = totalConnections;
+    }
+
+    public String setCountry(final String country) {
+        return this.country = country;
+    }
+
+    public String getCountry() {
+        return country;
+    }
+
+    public boolean hasNickname(final String nickname) {
+        return nicknames.contains(nickname);
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/AddressDataManager.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/AddressDataManager.java
new file mode 100644
index 00000000..007be392
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/AddressDataManager.java
@@ -0,0 +1,50 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.util.HashMap;
+import java.util.Map;
+
+public class AddressDataManager {
+    private Map<String, AddressData> addressData = new HashMap<>();
+
+    public String sanitizeAddress(String text) {
+        // Remove the port
+        int indexOfPort = text.indexOf(":");
+        if (indexOfPort != -1) {
+            text = text.substring(0, indexOfPort);
+        }
+
+        // Remove the slash at the start
+        if (text.startsWith("/")) {
+            text = text.substring(1);
+        }
+
+        return text;
+    }
+
+    public AddressData getAddressData(String addressString) {
+        addressString = sanitizeAddress(addressString);
+
+        if (addressData.containsKey(addressString)) {
+            return addressData.get(addressString);
+        } else {
+            AddressData data = new AddressData(addressString);
+
+            addressData.put(addressString, data);
+
+            return data;
+        }
+    }
+
+    public AddressData getAddressData(final SocketAddress address) {
+        final InetSocketAddress iNetSocketAddress = (InetSocketAddress) address;
+        final String addressString = iNetSocketAddress.getHostString();
+
+        return getAddressData(addressString);
+    }
+
+    public int getAddresCount() {
+        return addressData.size();
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/CheckManager.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/CheckManager.java
new file mode 100644
index 00000000..94fc7613
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/CheckManager.java
@@ -0,0 +1,49 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+import lombok.Getter;
+
+public class CheckManager {
+    @Getter
+    private final AccountsCheck accountsCheck;
+    @Getter
+    private final CountryCheck countryCheck;
+    @Getter
+    private final FastChatCheck fastChatCheck;
+    @Getter
+    private final NicknameCheck nicknameCheck;
+    @Getter
+    private final PasswordCheck passwordCheck;
+    @Getter
+    private final RatelimitCheck ratelimitCheck;
+    @Getter
+    private final ReconnectCheck reconnectCheck;
+    @Getter
+    private final PacketsCheck packetsCheck;
+    @Getter
+    private final ProxyCheck proxyCheck;
+
+    public CheckManager(final AddressDataManager addressDataManager, final MangoCordConfiguration mangoCordConfiguration) {
+        this.accountsCheck = new AccountsCheck(addressDataManager);
+        this.countryCheck = new CountryCheck(addressDataManager);
+        this.fastChatCheck = new FastChatCheck(addressDataManager);
+        this.nicknameCheck = new NicknameCheck(addressDataManager);
+        this.passwordCheck = new PasswordCheck(addressDataManager);
+        this.ratelimitCheck = new RatelimitCheck(addressDataManager);
+        this.reconnectCheck = new ReconnectCheck(addressDataManager);
+        this.packetsCheck = new PacketsCheck();
+        this.proxyCheck = new ProxyCheck(addressDataManager);
+
+        this.countryCheck.load();
+
+        if (MangoCord.getInstance().getMangoCordConfiguration().isAntibotProxyEnabled()) {
+            // run on a separated thread to avoid lock
+            new Thread(() -> this.proxyCheck.updateProxies()).start();
+        }
+    }
+
+    public void unload() {
+        this.countryCheck.unload();
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/CountryCheck.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/CountryCheck.java
new file mode 100644
index 00000000..9f65a2b3
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/CountryCheck.java
@@ -0,0 +1,150 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.net.URL;
+import java.nio.file.Files;
+import java.util.logging.Level;
+
+import com.maxmind.db.CHMCache;
+import com.maxmind.db.MaxMindDbConstructor;
+import com.maxmind.db.MaxMindDbParameter;
+import com.maxmind.db.Reader;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+
+public class CountryCheck {
+    private MangoCordConfiguration config;
+    private LoggerWrapper logger;
+    private AddressDataManager addressDataManager;
+    private Reader maxMindReader;
+
+    public CountryCheck(final AddressDataManager addressDataManager) {
+        this.config = MangoCord.getInstance().getMangoCordConfiguration();
+        this.logger = MangoCord.getInstance().getLoggerWrapper();
+        this.addressDataManager = addressDataManager;
+    }
+
+    public void download(final URL url, final File file) throws Exception {
+        try (InputStream in = url.openStream()) {
+            Files.copy(in, file.toPath());
+        }
+    }
+
+    public void load() {
+        if (!config.isAntibotCountryEnabled()) return;
+
+        final File file = new File("GeoLite2-Country.mmdb");
+
+        try {
+            if (!file.exists()) {
+                System.out.println("Starting download of MaxMindDB (This will take some seconds...)");
+                download(new URL("https://git.io/GeoLite2-Country.mmdb"), file);
+            }
+
+            this.maxMindReader = new Reader(file, new CHMCache());
+        } catch (final Exception exception) {
+            System.out.println("MaxMindDB was not able to download!");
+        }
+    }
+
+    public void unload() {
+        try {
+            if (this.maxMindReader != null) {
+                this.maxMindReader.close();
+            }
+        } catch (final IOException ex) {
+            // Ignored
+        }
+    }
+
+    private boolean isBlacklisted(final MangoCordConfiguration config, final String isoCode) {
+        for (final String blacklisted : config.getAntibotCountryBlacklist()) {
+            if (isoCode.contains(blacklisted)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public static class LookupResult {
+        private final Country country;
+
+        @MaxMindDbConstructor
+        public LookupResult(@MaxMindDbParameter(name = "country") final Country country) {
+            this.country = country;
+        }
+
+        public Country getCountry() {
+            return this.country;
+        }
+    }
+
+    public static class Country {
+        private final String isoCode;
+
+        @MaxMindDbConstructor
+        public Country(@MaxMindDbParameter(name = "iso_code") final String isoCode) {
+            this.isoCode = isoCode;
+        }
+
+        public String getIsoCode() {
+            return this.isoCode;
+        }
+    }
+
+    public String getIsoCode(final InetAddress address) {
+        try {
+            final LookupResult lookupResult = maxMindReader.get(address, LookupResult.class);
+
+            if (lookupResult == null) {
+                return "LOCAL";
+            } else {
+                final Country country = lookupResult.getCountry();
+                final String isoCode = country.getIsoCode();
+
+                return isoCode;
+            }
+        } catch (final Exception exception) {
+            // Ignored
+        }
+
+        return null;
+    }
+
+    public boolean check(final SocketAddress remoteAddress) {
+        if (config.isAntibotCountryEnabled()) {
+            final AddressData addressData = addressDataManager.getAddressData(remoteAddress);
+            final String addressCountry = addressData.getCountry();
+            final String country;
+
+            if (addressCountry != null) {
+                country = addressCountry;
+            } else {
+                country = getIsoCode(((InetSocketAddress) remoteAddress).getAddress());
+                addressData.setCountry(country);
+            }
+
+            if (country != null && isBlacklisted(config, country)) {
+                if (config.isAntibotCountryLog()) {
+                    logger.log(Level.INFO,
+                            "[Mangocord] [{0}] has his country blocked from the server", remoteAddress);
+                }
+
+                if (config.isAntibotCountryFirewall()) {
+                    addressData.firewall("Blacklisted country");
+                }
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/FastChatCheck.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/FastChatCheck.java
new file mode 100644
index 00000000..e2140887
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/FastChatCheck.java
@@ -0,0 +1,39 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.net.SocketAddress;
+import java.util.logging.Level;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+
+public class FastChatCheck {
+    private MangoCordConfiguration config;
+    private LoggerWrapper logger;
+    private final AddressDataManager addressDataManager;
+
+    public FastChatCheck(final AddressDataManager addressDataManager) {
+        this.config = MangoCord.getInstance().getMangoCordConfiguration();
+        this.logger = MangoCord.getInstance().getLoggerWrapper();
+        this.addressDataManager = addressDataManager;
+    }
+
+    public boolean check(final SocketAddress remoteAddress) {
+        if (config.isAntibotFastChatEnabled()) {
+            final AddressData addressData = addressDataManager.getAddressData(remoteAddress);
+
+            if (addressData.getTimeSinceLastConnection() <= config.getAntibotFastChatTime()) {
+                if (config.isAntibotFastChatLog()) {
+                    logger.log(Level.INFO, "[Mangocord] [{0}] is chatting too fast", remoteAddress);
+                }
+
+                if (config.isAntibotFastChatFirewall()) {
+                    addressData.firewall("Too fast chatting");
+                }
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/LoggerWrapper.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/LoggerWrapper.java
new file mode 100644
index 00000000..5ae7580e
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/LoggerWrapper.java
@@ -0,0 +1,32 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class LoggerWrapper {
+    private Logger logger;
+
+    // Last time a log was done
+    private long lastLog = System.currentTimeMillis();
+
+    public LoggerWrapper(Logger logger) {
+        this.logger = logger;
+    }
+
+    public void log(Level level, String msg, Object ...params) {
+        long currentTime = System.currentTimeMillis();
+
+        // Throttle logs by 100ms
+        if (currentTime - lastLog > 100) {
+            // Set the last log
+            lastLog = currentTime;
+
+            // Log the text
+            logger.log(level, msg, params);
+        }
+    }
+
+    public Logger getLogger() {
+        return logger;
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/NicknameCheck.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/NicknameCheck.java
new file mode 100644
index 00000000..1b35fba5
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/NicknameCheck.java
@@ -0,0 +1,52 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.net.SocketAddress;
+import java.util.logging.Level;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+
+public class NicknameCheck {
+    private MangoCordConfiguration config;
+    private LoggerWrapper logger;
+    private AddressDataManager addressDataManager;
+
+    public NicknameCheck(final AddressDataManager addressDataManager) {
+        this.config = MangoCord.getInstance().getMangoCordConfiguration();
+        this.logger = MangoCord.getInstance().getLoggerWrapper();
+        this.addressDataManager = addressDataManager;
+    }
+
+    private boolean isBlacklisted(final MangoCordConfiguration config, final String nickname) {
+        String lowerNickname = nickname.toLowerCase();
+
+        for (final String blacklisted : config.getAntibotNicknameBlacklist()) {
+            if (lowerNickname.contains(blacklisted)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public boolean check(final SocketAddress remoteAddress) {
+        if (config.isAntibotNicknameEnabled()) {
+            final AddressData addressData = addressDataManager.getAddressData(remoteAddress);
+            final String nickname = addressData.getLastNickname();
+
+            if (isBlacklisted(config, nickname)) {
+                if (config.isAntibotNicknameLog()) {
+                    logger.log(Level.INFO, "[Mangocord] [{0}] has a blacklisted nickname (" + nickname + ")", remoteAddress);
+                }
+
+                if (config.isAntibotNicknameFirewall()) {
+                    addressData.firewall("Blacklisted nickname [" + nickname + "]");
+                }
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/PacketsCheck.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/PacketsCheck.java
new file mode 100644
index 00000000..6249fe8e
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/PacketsCheck.java
@@ -0,0 +1,63 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.net.SocketAddress;
+import java.util.HashMap;
+import java.util.Map;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+import dev.lucianishimiya.mangcord.enums.PacketsCheckResult;
+import dev.lucianishimiya.mangcord.enums.PacketsViolationReason;
+import dev.lucianishimiya.mangcord.utils.ProtocolUtil;
+import io.netty.buffer.ByteBuf;
+
+public class PacketsCheck {
+    private Map<String, PacketsData> packetsData = new HashMap<>();
+
+    public PacketsData getData(SocketAddress address) {
+        // Get the ip
+        String ip = address.toString();
+
+        // Check if 60 seconds passed
+        if (System.currentTimeMillis() % 60000 == 0) {
+            packetsData.clear();
+        }
+
+        if (packetsData.containsKey(ip)) {
+            return packetsData.get(ip);
+        } else {
+            PacketsData data = new PacketsData(address);
+
+            packetsData.put(ip, data);
+
+            return data;
+        }
+    }
+
+    public PacketsCheckResult check(SocketAddress socketAddress, ByteBuf byteBuf) {
+        MangoCordConfiguration config = MangoCord.getInstance().getMangoCordConfiguration();
+
+        if (!config.isAntibotPacketsEnabled()) {
+            return PacketsCheckResult.NONE;
+        }
+
+        PacketsData packetsData = getData(socketAddress);
+        int length = byteBuf.readableBytes();
+        int index = byteBuf.readerIndex();
+        int packetId = ProtocolUtil.readVarInt(byteBuf);
+        byteBuf.readerIndex(index);
+
+        packetsData.addVls(length * config.getAntibotPacketsVlsPerByte(), PacketsViolationReason.SIZE, packetId);
+        packetsData.addVls(config.getAntibotPacketsVlsPerPacket(), PacketsViolationReason.RATE, packetId);
+
+        double vls = packetsData.getPacketsVls();
+
+        if (vls >= config.getAntibotPacketsVlsToKick()) {
+            return PacketsCheckResult.KICK;
+        } else if (vls >= config.getAntibotPacketsVlsToCancel()) {
+            return PacketsCheckResult.CANCEL;
+        } else {
+            return PacketsCheckResult.NONE;
+        }
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/PacketsData.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/PacketsData.java
new file mode 100644
index 00000000..7189a7f3
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/PacketsData.java
@@ -0,0 +1,115 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.net.SocketAddress;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.enums.PacketsViolationReason;
+
+public class PacketsData {
+    // The address related to this data
+    private SocketAddress address;
+
+    // The vls of the current address
+    private double packetsVls = 0;
+
+    // The vls of the current address because of size
+    private double packetsVlsSize = 0;
+
+    // The vls of the current address because of rate
+    private double packetsVlsRate = 0;
+
+    // The last time vls was calculated
+    private long lastVlsCalculated = System.currentTimeMillis();
+
+    // The vls by packet ids
+    private Map<Integer, Double> vlsByPacketId = new HashMap<>();
+
+    // If cancellation was printed
+    private boolean cancelPrinted = false;
+
+    public PacketsData(SocketAddress address) {
+        this.address = address;
+    }
+
+    public double simplify(double number) {
+        return (double) (int) (number * 1000) / 1000;
+    }
+
+    public void printKick() {
+        if (MangoCord.getInstance().getMangoCordConfiguration().isAntibotPacketsLog()) {
+            System.out
+                    .println("[Mangocord] [" + address
+                            + "] was kicked because of too many packets (Total: " + simplify(packetsVls) + "vls Size: "
+                            + simplify(packetsVlsSize) + "vls Rate: " + simplify(packetsVlsRate) + "vls)");
+        }
+    }
+
+    public void printCancel() {
+        if (MangoCord.getInstance().getMangoCordConfiguration().isAntibotPacketsLog() && !cancelPrinted) {
+            System.out
+                    .println("[Mangocord] [" + address
+                            + "] was cancelled because of too many packets (Total: " + simplify(packetsVls) + "vls Size: "
+                            + simplify(packetsVlsSize) + "vls Rate: " + simplify(packetsVlsRate) + "vls)");
+                            this.cancelPrinted = true;
+        }
+    }
+
+    public void printPackets() {
+        if (MangoCord.getInstance().getMangoCordConfiguration().isAntibotPacketsDebug()
+                && simplify(this.packetsVls) > 0) {
+            System.out
+                    .println("[Mangocord] [" + address
+                            + "] debug is enabled, showing stats (Total: " + simplify(packetsVls) + "vls Size: "
+                            + simplify(packetsVlsSize) + "vls Rate: " + simplify(packetsVlsRate) + "vls)");
+            for (Entry<Integer, Double> entry : this.vlsByPacketId.entrySet()) {
+                System.out.print(entry.getKey() + "-" + simplify(entry.getValue()) + "vls, ");
+            }
+            System.out.println("");
+        }
+    }
+
+    public double getPacketsVls() {
+        if (System.currentTimeMillis() - lastVlsCalculated >= 1000) {
+            printPackets();
+
+            this.cancelPrinted = false;
+            this.packetsVls = 0;
+            this.packetsVlsSize = 0;
+            this.packetsVlsRate = 0;
+            this.vlsByPacketId.clear();
+            this.lastVlsCalculated = System.currentTimeMillis();
+        }
+
+        return packetsVls;
+    }
+
+    public void addVls(double packetsVls, PacketsViolationReason reason, int packetId) {
+        this.packetsVls += packetsVls;
+        this.vlsByPacketId.put(packetId, this.vlsByPacketId.getOrDefault(packetId, 0.0) + packetsVls);
+
+        switch (reason) {
+            case SIZE: {
+                this.packetsVlsSize += packetsVls;
+                break;
+            }
+            case RATE: {
+                this.packetsVlsRate += packetsVls;
+                break;
+            }
+            default: {
+                break;
+            }
+        }
+    }
+
+    public double getPacketsVlsSize() {
+        return packetsVlsSize;
+    }
+
+    public double getPacketsVlsRate() {
+        return packetsVlsRate;
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/PasswordCheck.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/PasswordCheck.java
new file mode 100644
index 00000000..68555de3
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/PasswordCheck.java
@@ -0,0 +1,69 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.net.SocketAddress;
+import java.util.logging.Level;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+
+public class PasswordCheck {
+    private MangoCordConfiguration config;
+    private AddressDataManager addressDataManager;
+    private LoggerWrapper logger;
+    private String lastNickname = "";
+    private String lastPassword = "";
+    private int repeatCount = 0;
+
+    public PasswordCheck(final AddressDataManager addressDataManager) {
+        this.config = MangoCord.getInstance().getMangoCordConfiguration();
+        this.logger = MangoCord.getInstance().getLoggerWrapper();
+        this.addressDataManager = addressDataManager;
+    }
+
+    private void updatePassword(final MangoCordConfiguration config, final String nickname, final String password) {
+        if (!nickname.equals(lastNickname)) {
+            if (password.equals(lastPassword)) {
+                if (repeatCount < config.getAntibotPasswordLimit()) {
+                    repeatCount++;
+                }
+            } else if (repeatCount > 0) {
+                repeatCount--;
+            }
+        }
+
+        lastNickname = nickname;
+        lastPassword = password;
+    }
+
+    public boolean check(final SocketAddress remoteAddress, final String passwordMessage) {
+        if (config.isAntibotPasswordEnabled()) {
+            if (passwordMessage.contains("/login ") || passwordMessage.contains("/l ")
+                    || passwordMessage.contains("/register ")
+                    || passwordMessage.contains("/reg ")) {
+                final AddressData addressData = addressDataManager.getAddressData(remoteAddress);
+                final String nickname = addressData.getLastNickname();
+                final String password = passwordMessage.split(" ")[1];
+
+                updatePassword(config, nickname, password);
+
+                if (repeatCount >= config.getAntibotPasswordLimit()) {
+                    if (config.isAntibotPasswordLog()) {
+                        logger.log(Level.INFO, "[Mangocord] [{0}] has entered a repeated password", remoteAddress);
+                    }
+
+                    if (config.isAntibotPasswordFirewall()) {
+                        addressData.firewall("Repeated password");
+                    }
+
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    public int getRepeatCount() {
+        return repeatCount;
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/ProxyCheck.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/ProxyCheck.java
new file mode 100644
index 00000000..3b3d4d2f
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/ProxyCheck.java
@@ -0,0 +1,180 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.SocketAddress;
+import java.net.URL;
+import java.util.Collection;
+import java.util.logging.Level;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+
+public class ProxyCheck {
+    private MangoCordConfiguration config;
+    private LoggerWrapper logger;
+    private AddressDataManager addressDataManager;
+    private String proxies = "";
+
+    public ProxyCheck(AddressDataManager addressDataManager) {
+        this.addressDataManager = addressDataManager;
+        this.config = MangoCord.getInstance().getMangoCordConfiguration();
+        this.logger = MangoCord.getInstance().getLoggerWrapper();
+    }
+
+    public void updateProxies() {
+        // define the websites to get the proxies from
+        Collection<String> lists = config.getAntibotProxyLists();
+
+        // send updating proxies message
+        MangoCord.getInstance().getLoggerWrapper().getLogger()
+                .info("[Mangocord] Updating proxy database from " + lists.size() + " websites... (It can take a while!)");
+
+        // create a string builder to store the content
+        StringBuilder content = new StringBuilder();
+
+        // create the proxy count
+        int proxyCount = 0;
+
+        // create the time took
+        long timeTook = System.currentTimeMillis();
+
+        // loop through each website
+        for (String website : lists) {
+            try {
+                // create a URL object with the website
+                URL url = new URL(website);
+
+                // open a connection to the URL
+                HttpURLConnection con = (HttpURLConnection) url.openConnection();
+
+                // set timeouts
+                con.setConnectTimeout (5000);
+                con.setReadTimeout (5000);
+
+                // set the request method to GET
+                con.setRequestMethod("GET");
+
+                // get the response code
+                int responseCode = con.getResponseCode();
+
+                // if the response code is OK (200)
+                if (responseCode == HttpURLConnection.HTTP_OK) {
+                    // create a buffered reader to read the response
+                    BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
+
+                    // read each line of the response and append it to the content
+                    String inputLine;
+                    while ((inputLine = in.readLine()) != null) {
+                        // check if not a comment and content does not contain the ip already
+                        if (!inputLine.startsWith("#") && content.indexOf(inputLine) == -1) {
+                            content.append(inputLine);
+                            content.append("\n");
+                            proxyCount++;
+                        }
+                    }
+
+                    // close the buffered reader
+                    in.close();
+                } else {
+                    // print an error message
+                    MangoCord.getInstance().getLoggerWrapper().log(Level.INFO, "GET request failed for " + website);
+                }
+            } catch (Exception ex) {
+                // print an error message
+                MangoCord.getInstance().getLoggerWrapper().log(Level.INFO, "GET request failed for " + website);
+            }
+        }
+
+        // update time took
+        timeTook = (System.currentTimeMillis() - timeTook) / 1000;
+
+        // send updated proxies message
+        MangoCord.getInstance().getLoggerWrapper().getLogger()
+                .info("[Mangocord] Loaded a total of " + proxyCount + " proxies to the database! (Took " + timeTook + " seconds)");
+
+        // set the updated proxy list
+        proxies = content.toString();
+    }
+
+    public boolean check(String ip) {
+        return !proxies.equals("") && proxies.contains(ip);
+    }
+
+    public boolean check(SocketAddress address) {
+        if (!config.isAntibotProxyEnabled())
+            return false;
+
+        AddressData addressData = addressDataManager.getAddressData(address);
+        String ip = addressData.getHostString();
+        Collection<String> whitelist = config.getAntibotProxyWhitelist();
+
+        // Check if the ip is whitelisted
+        if (whitelist.contains(ip)) {
+            return false;
+        }
+
+        // Check if it's a proxy
+        if ((!proxies.equals("") && proxies.contains(ip)) || isVPN(ip)) {
+            if (config.isAntibotProxyLog()) {
+                logger.log(Level.INFO, "[Mangocord] [{0}] was blocked for using a VPN/Proxy service", address);
+            }
+
+            if (config.isAntibotProxyFirewall()) {
+                addressData.firewall("Using VPN/proxy services");
+            }
+
+            return true;
+        }
+
+        return false;
+    }
+
+    // Method to check if an IP address is a VPN using getipintel API
+    public boolean isVPN(String ip) {
+        if (!config.isAntibotProxyOnlineCheck())
+            return false;
+
+        try {
+            // Create a URL object with the API endpoint and the IP parameter
+            URL url = new URL("https://check.getipintel.net/check.php?ip=" + ip + "&contact=" + MangoCord.getInstance().getMangoCordConfiguration().getAntibotProxyEmail());
+
+            // Open a connection to the URL
+            HttpURLConnection con = (HttpURLConnection) url.openConnection();
+
+            // Set the request method to GET
+            con.setRequestMethod("GET");
+
+            // Get the response code
+            int responseCode = con.getResponseCode();
+
+            // If the response code is 200 (OK), read the input stream
+            if (responseCode == 200) {
+                // Read the response from the input stream
+                BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));
+                String line;
+                StringBuilder response = new StringBuilder();
+
+                while ((line = in.readLine()) != null) {
+                    response.append(line);
+                }
+                in.close();
+
+                // Parse the response as a double
+                double result = Double.parseDouble(response.toString());
+
+                // If the result is greater than 0.99, it is a VPN
+                if (result > 0.99) {
+                    return true;
+                } else {
+                    return false;
+                }
+            } else {
+                return false;
+            }
+        } catch (Exception e) {
+            return false;
+        }
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/RatelimitCheck.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/RatelimitCheck.java
new file mode 100644
index 00000000..51c1866e
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/RatelimitCheck.java
@@ -0,0 +1,52 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.net.SocketAddress;
+import java.util.logging.Level;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+
+public class RatelimitCheck {
+    private MangoCordConfiguration config;
+    private LoggerWrapper logger;
+    private AddressDataManager addressDataManager;
+
+    public RatelimitCheck(final AddressDataManager addressDataManager) {
+        this.config = MangoCord.getInstance().getMangoCordConfiguration();
+        this.logger = MangoCord.getInstance().getLoggerWrapper();
+        this.addressDataManager = addressDataManager;
+    }
+
+    public boolean check(final SocketAddress remoteAddress, int protocol) {
+        if (config.isAntibotRatelimitEnabled()) {
+            AddressData addressData = addressDataManager.getAddressData(remoteAddress);
+
+            if (config.getAntibotRatelimitWhitelist().contains(addressData.getHostString())) {
+                return false;
+            }
+
+            if (addressData.getConnectionsSecond() >= config.getAntibotRatelimitConnectionsPerSecond()
+                    || addressData.getPingsSecond() >= config.getAntibotRatelimitPingsPerSecond()) {
+                if (config.isAntibotRatelimitLog()) {
+                    if (protocol == 1) {
+                        logger.log(Level.INFO, "[Mangocord] [{0}] is pinging too fast", remoteAddress);
+                    } else {
+                        logger.log(Level.INFO, "[Mangocord] [{0}] is connecting too fast", remoteAddress);
+                    }
+                }
+
+                if (config.isAntibotRatelimitFirewall()) {
+                    if (protocol == 1) {
+                        addressData.firewall("Too many pings");
+                    } else {
+                        addressData.firewall("Too many connections");
+                    }
+                }
+
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/ReconnectCheck.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/ReconnectCheck.java
new file mode 100644
index 00000000..d38ffc9e
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/ReconnectCheck.java
@@ -0,0 +1,53 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+import java.net.SocketAddress;
+import java.util.logging.Level;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
+
+public class ReconnectCheck {
+    private MangoCordConfiguration config;
+    private LoggerWrapper logger;
+    private AddressDataManager addressDataManager;
+    private int connections = 0;
+    private long lastConnection = 0;
+
+    public ReconnectCheck(final AddressDataManager addressDataManager) {
+        this.config = MangoCord.getInstance().getMangoCordConfiguration();
+        this.logger = MangoCord.getInstance().getLoggerWrapper();
+        this.addressDataManager = addressDataManager;
+    }
+
+    public boolean check(final SocketAddress remoteAddress) {
+        if (config.isAntibotReconnectEnabled()) {
+            final long currentTime = System.currentTimeMillis();
+
+            if (currentTime - lastConnection > config.getAntibotReconnectConnectionThresholdLimit()) {
+                lastConnection = currentTime;
+                connections = 0;
+            }
+
+            if (++connections > config.getAntibotReconnectConnectionThreshold()) {
+                final AddressData addressData = addressDataManager.getAddressData(remoteAddress);
+                final boolean needsAttempts = addressData.getTotalConnections() < config.getAntibotReconnectAttempts()
+                        || addressData.getTotalPings() < config.getAntibotReconnectPings();
+                final boolean tooSlow = addressData.getTimeSincePenultimateConnection() > config
+                        .getAntibotReconnectMaxTime();
+
+                if (tooSlow) {
+                    if (config.isAntibotReconnectLog()) {
+                        logger.log(Level.INFO, "[Mangocord] [{0}] has to reconnect to join", remoteAddress);
+                    }
+
+                    addressData.setTotalConnections(0);
+                    return true;
+                } else {
+                    return needsAttempts;
+                }
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/StatsData.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/StatsData.java
new file mode 100644
index 00000000..44d773ab
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/antibot/StatsData.java
@@ -0,0 +1,75 @@
+package dev.lucianishimiya.mangcord.antibot;
+
+public class StatsData {
+    // Time of the last second
+    private long lastSecond = System.currentTimeMillis();
+
+    // Total pings and connections
+    private int totalPings = 0;
+    private int totalConnections = 0;
+
+    // Current second connections and pings
+    private int currentPings = 0;
+    private int currentConnections = 0;
+
+    // Last second connections and pings
+    private int lastPings = 0;
+    private int lastConnections = 0;
+
+    public void resetData() {
+        // Get current time
+        long currentTime = System.currentTimeMillis();
+
+        // Check if one second passed
+        if (currentTime - lastSecond > 1000) {
+            // Set the last second to this one
+            lastSecond = currentTime;
+
+            // Reset the data
+            lastPings = currentPings;
+            lastConnections = currentConnections;
+            currentPings = 0;
+            currentConnections = 0;
+        }
+    }
+
+    public void addPing() {
+        resetData();
+        currentPings++;
+        totalPings++;
+    }
+
+    public void addConnection() {
+        resetData();
+        currentConnections++;
+        totalConnections++;
+    }
+
+    public int getCurrentPings() {
+        resetData();
+        return currentPings;
+    }
+
+    public int getCurrentConnections() {
+        resetData();
+        return currentConnections;
+    }
+
+    public int getLastPings() {
+        resetData();
+        return lastPings;
+    }
+
+    public int getLastConnections() {
+        resetData();
+        return lastConnections;
+    }
+
+    public int getTotalPings() {
+        return totalPings;
+    }
+
+    public int getTotalConnections() {
+        return totalConnections;
+    }
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/configuration/MangoCordConfiguration.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/configuration/MangoCordConfiguration.java
index 14665b1f..241f5a0e 100644
--- a/mangcord/src/main/java/dev/lucianishimiya/mangcord/configuration/MangoCordConfiguration.java
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/configuration/MangoCordConfiguration.java
@@ -15,6 +15,223 @@ import net.md_5.bungee.config.Configuration;
 import net.md_5.bungee.config.ConfigurationProvider;
 
 public class MangoCordConfiguration extends MangoConfig {
+    // Antibot accounts
+    @Getter
+    private boolean antibotAccountsEnabled = true;
+    @Getter
+    private boolean antibotAccountsFirewall = true;
+    @Getter
+    private int antibotAccountsLimit = 3;
+    @Getter
+    private boolean antibotAccountsLog = true;
+    @Getter
+    private Collection<String> antibotAccountsWhitelist = Arrays.asList("Nickname");
+
+    // Antibot country
+    @Getter
+    private boolean antibotCountryEnabled = true;
+    @Getter
+    private boolean antibotCountryFirewall = true;
+    @Getter
+    private Collection<String> antibotCountryBlacklist = Arrays.asList("CN", "HK", "RU", "IN", "TH", "ID", "DZ", "VN", "IR", "PK");
+    @Getter
+    private Collection<String> antibotFirewalledExceptions = Arrays.asList("BadPacketException", "QuietException", "IllegalStateConfig", "FastException");
+    @Getter
+    private boolean antibotCountryLog = true;
+
+    // Antibot fastchat
+    @Getter
+    private boolean antibotFastChatEnabled = true;
+    @Getter
+    private boolean antibotFastChatFirewall = true;
+    @Getter
+    private int antibotFastChatTime = 1000;
+    @Getter
+    private boolean antibotFastChatLog = true;
+
+    // Antibot firewall
+    @Getter
+    private boolean antibotFirewallEnabled = true;
+    @Getter
+    private int antibotFirewallExpire = 60;
+    @Getter
+    private boolean antibotFirewallLog = true;
+    @Getter
+    private boolean antibotFirewallIpset = true;
+    @Getter
+    private Collection<String> antibotFirewallWhitelist = Arrays.asList("127.0.0.1");
+
+    // Antibot nickname
+    @Getter
+    private boolean antibotNicknameEnabled = true;
+    @Getter
+    private boolean antibotNicknameFirewall = true;
+    @Getter
+    private Collection<String> antibotNicknameBlacklist = Arrays.asList("mcstorm", "mcdown", "mcbot", "theresa_bot", "dropbot", "kingbot");
+    @Getter
+    private boolean antibotNicknameLog = true;
+
+    // Antibot password
+    @Getter
+    private boolean antibotPasswordEnabled = true;
+    @Getter
+    private boolean antibotPasswordFirewall = true;
+    @Getter
+    private int antibotPasswordLimit = 3;
+    @Getter
+    private boolean antibotPasswordLog = true;
+
+    // Antibot ratelimit
+    @Getter
+    private boolean antibotRatelimitEnabled = true;
+    @Getter
+    private boolean antibotRatelimitFirewall = true;
+    @Getter
+    private int antibotRatelimitConnectionsPerSecond = 3;
+    @Getter
+    private int antibotRatelimitPingsPerSecond = 8;
+    @Getter
+    private boolean antibotRatelimitLog = true;
+    @Getter
+    private Collection<String> antibotRatelimitWhitelist = Arrays.asList("127.0.0.1");
+
+    // Antibot reconnect
+    @Getter
+    private boolean antibotReconnectEnabled = true;
+    @Getter
+    private int antibotReconnectAttempts = 2;
+    @Getter
+    private int antibotReconnectPings = 1;
+    @Getter
+    private int antibotReconnectMaxTime = 10000;
+    @Getter
+    private int antibotReconnectConnectionThreshold = 1;
+    @Getter
+    private int antibotReconnectConnectionThresholdLimit = 8000;
+    @Getter
+    private boolean antibotReconnectLog = true;
+
+    // Antibot packets
+    @Getter
+    private boolean antibotPacketsEnabled = true;
+    @Getter
+    private boolean antibotPacketsLog = true;
+    @Getter
+    private boolean antibotPacketsDebug = false;
+    @Getter
+    private double antibotPacketsVlsPerByte = 0.0017;
+    @Getter
+    private double antibotPacketsVlsPerPacket = 0.1;
+    @Getter
+    private double antibotPacketsVlsToKick = 100;
+    @Getter
+    private double antibotPacketsVlsToCancel = 25;
+
+    // Antibot proxy
+    @Getter
+    private boolean antibotProxyEnabled = true;
+    @Getter
+    private boolean antibotProxyLog = true;
+    @Getter
+    private boolean antibotProxyFirewall = true;
+    @Getter
+    private boolean antibotProxyOnlineCheck = false;
+    @Getter
+    private String antibotProxyEmail = "mangcord@gmail.com";
+    @Getter
+    private Collection<String> antibotProxyWhitelist = Arrays.asList("127.0.0.1");
+    @Getter
+    private Collection<String> antibotProxyLists = Arrays.asList(
+        "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/http.txt",
+        "https://raw.githubusercontent.com/clarketm/proxy-list/master/proxy-list-raw.txt",
+        "https://raw.githubusercontent.com/mertguvencli/http-proxy-list/main/proxy-list/data.txt",
+        "https://raw.githubusercontent.com/scriptzteam/ProtonVPN-VPN-IPs/main/exit_ips.txt",
+        "https://raw.githubusercontent.com/mmpx12/proxy-list/master/ips-list.txt",
+        "https://check.torproject.org/torbulkexitlist?ip=1.1.1.1",
+        "https://cinsscore.com/list/ci-badguys.txt",
+        "https://lists.blocklist.de/lists/all.txt",
+        "https://blocklist.greensnow.co/greensnow.txt",
+        "https://raw.githubusercontent.com/firehol/blocklist-ipsets/master/stopforumspam_7d.ipset"
+        );
+
+    public void loadAntibot(final Configuration config, final Collection<String> whitelistedAddresses) {
+        // Antibot accounts
+        this.antibotAccountsEnabled = setIfUnexistant("antibot.accounts.enabled", this.antibotAccountsEnabled, config);
+        this.antibotAccountsFirewall = setIfUnexistant("antibot.accounts.firewall", this.antibotAccountsFirewall, config);
+        this.antibotAccountsLimit = setIfUnexistant("antibot.accounts.limit", this.antibotAccountsLimit, config);
+        this.antibotAccountsLog = setIfUnexistant("antibot.accounts.log", this.antibotAccountsLog, config);
+        this.antibotAccountsWhitelist = setIfUnexistant("antibot.accounts.whitelist", this.antibotAccountsWhitelist, config);
+
+        // Antibot country
+        this.antibotCountryEnabled = setIfUnexistant("antibot.country.enabled", this.antibotCountryEnabled, config);
+        this.antibotCountryFirewall = setIfUnexistant("antibot.country.firewall", this.antibotCountryFirewall, config);
+        this.antibotCountryBlacklist = setIfUnexistant("antibot.country.blacklist", this.antibotCountryBlacklist, config);
+        this.antibotCountryLog = setIfUnexistant("antibot.country.log", this.antibotCountryLog, config);
+
+        // Antibot fastchat
+        this.antibotFastChatEnabled = setIfUnexistant("antibot.fastchat.enabled", this.antibotFastChatEnabled, config);
+        this.antibotFastChatFirewall = setIfUnexistant("antibot.fastchat.firewall", this.antibotFastChatFirewall, config);
+        this.antibotFastChatTime = setIfUnexistant("antibot.fastchat.time", this.antibotFastChatTime, config);
+        this.antibotFastChatLog = setIfUnexistant("antibot.fastchat.log", this.antibotFastChatLog, config);
+
+        // Antibot firewall
+        this.antibotFirewallEnabled = setIfUnexistant("antibot.firewall.enabled", this.antibotFirewallEnabled, config);
+        this.antibotFirewalledExceptions = setIfUnexistant("antibot.firewall.exceptions", this.antibotFirewalledExceptions, config);
+        this.antibotFirewallExpire = setIfUnexistant("antibot.firewall.time", this.antibotFirewallExpire, config);
+        this.antibotFirewallLog = setIfUnexistant("antibot.firewall.log", this.antibotFirewallLog, config);
+        this.antibotFirewallWhitelist = new HashSet<>( setIfUnexistant("antibot.firewall.whitelist", this.antibotFirewallWhitelist, config ));
+        this.antibotFirewallIpset = setIfUnexistant("antibot.firewall.ipset", this.antibotFirewallIpset, config);
+
+        // Add local server ips to whitelist
+        this.antibotFirewallWhitelist.addAll(whitelistedAddresses);
+
+        // Antibot nickname
+        this.antibotNicknameEnabled = setIfUnexistant("antibot.nickname.enabled", this.antibotNicknameEnabled, config);
+        this.antibotNicknameFirewall = setIfUnexistant("antibot.nickname.firewall", this.antibotNicknameFirewall, config);
+        this.antibotNicknameBlacklist = setIfUnexistant("antibot.nickname.blacklist", this.antibotNicknameBlacklist, config);
+        this.antibotNicknameLog = setIfUnexistant("antibot.nickname.log", this.antibotNicknameLog, config);
+
+        // Antibot password
+        this.antibotPasswordEnabled = setIfUnexistant("antibot.password.enabled", this.antibotPasswordEnabled, config);
+        this.antibotPasswordFirewall = setIfUnexistant("antibot.password.firewall", this.antibotPasswordFirewall, config);
+        this.antibotPasswordLimit = setIfUnexistant("antibot.password.limit", this.antibotPasswordLimit, config);
+        this.antibotPasswordLog = setIfUnexistant("antibot.password.log", this.antibotPasswordLog, config);
+
+        // Antibot ratelimit
+        this.antibotRatelimitEnabled = setIfUnexistant("antibot.ratelimit.enabled", this.antibotRatelimitEnabled, config);
+        this.antibotRatelimitFirewall = setIfUnexistant("antibot.ratelimit.firewall", this.antibotRatelimitFirewall, config);
+        this.antibotRatelimitConnectionsPerSecond = setIfUnexistant("antibot.ratelimit.connections-per-second", this.antibotRatelimitConnectionsPerSecond, config);
+        this.antibotRatelimitPingsPerSecond = setIfUnexistant("antibot.ratelimit.pings-per-second", this.antibotRatelimitPingsPerSecond, config);
+        this.antibotRatelimitLog = setIfUnexistant("antibot.ratelimit.log", this.antibotRatelimitLog, config);
+        this.antibotRatelimitWhitelist = new HashSet<>( setIfUnexistant("antibot.ratelimit.whitelist", this.antibotRatelimitWhitelist, config ));
+
+        // Antibot reconnect
+        this.antibotReconnectEnabled = setIfUnexistant("antibot.reconnect.enabled", this.antibotReconnectEnabled, config);
+        this.antibotReconnectAttempts = setIfUnexistant("antibot.reconnect.attempts", this.antibotReconnectAttempts, config);
+        this.antibotReconnectPings = setIfUnexistant("antibot.reconnect.pings", this.antibotReconnectPings, config);
+        this.antibotReconnectMaxTime = setIfUnexistant("antibot.reconnect.max-time", this.antibotReconnectMaxTime, config);
+        this.antibotReconnectConnectionThreshold = setIfUnexistant("antibot.reconnect.connection-threshold", this.antibotReconnectConnectionThreshold, config);
+        this.antibotReconnectConnectionThresholdLimit = setIfUnexistant("antibot.reconnect.connection-threshold-limit", this.antibotReconnectConnectionThresholdLimit, config);
+        this.antibotReconnectLog = setIfUnexistant("antibot.reconnect.log", this.antibotReconnectLog, config);
+
+        // Antibot packets
+        this.antibotPacketsEnabled = setIfUnexistant("antibot.packets.enabled", this.antibotPacketsEnabled, config);
+        this.antibotPacketsLog = setIfUnexistant("antibot.packets.log", this.antibotPacketsLog, config);
+        this.antibotPacketsDebug = setIfUnexistant("antibot.packets.debug", this.antibotPacketsDebug, config);
+        this.antibotPacketsVlsPerByte = setIfUnexistant("antibot.packets.vls-per-byte", this.antibotPacketsVlsPerByte, config);
+        this.antibotPacketsVlsPerPacket = setIfUnexistant("antibot.packets.vls-per-packet", this.antibotPacketsVlsPerPacket, config);
+        this.antibotPacketsVlsToKick = setIfUnexistant("antibot.packets.vls-to-kick", this.antibotPacketsVlsToKick, config);
+
+        // Antibot proxy
+        this.antibotProxyEnabled = setIfUnexistant("antibot.proxy.enabled", this.antibotProxyEnabled, config);
+        this.antibotProxyLog = setIfUnexistant("antibot.proxy.log", this.antibotProxyLog, config);
+        this.antibotProxyFirewall = setIfUnexistant("antibot.proxy.firewall", this.antibotProxyFirewall, config);
+        this.antibotProxyOnlineCheck = setIfUnexistant("antibot.proxy.online-check", this.antibotProxyOnlineCheck, config);
+        this.antibotProxyEmail = setIfUnexistant("antibot.proxy.email", this.antibotProxyEmail, config);
+        this.antibotProxyWhitelist = setIfUnexistant("antibot.proxy.whitelist", this.antibotProxyWhitelist, config);
+        this.antibotProxyLists = setIfUnexistant("antibot.proxy.lists", this.antibotProxyLists, config);
+    }
+
     // MangoCord - TCP Fast Open
     @Getter
     private int tcpFastOpen = 3;
@@ -133,6 +350,9 @@ public class MangoCordConfiguration extends MangoConfig {
 
         this.tcpFastOpen = setIfUnexistant("tcp-fast-open", this.tcpFastOpen, configuration);
 
+        // MangoCord - Antibot System
+        loadAntibot(configuration, whitelistedAddresses);
+
         save(configuration, configurationFile);
     }
 }
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/configuration/MessagesConfiguration.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/configuration/MessagesConfiguration.java
index ae179438..820b012b 100644
--- a/mangcord/src/main/java/dev/lucianishimiya/mangcord/configuration/MessagesConfiguration.java
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/configuration/MessagesConfiguration.java
@@ -80,6 +80,23 @@ public class MessagesConfiguration extends MangoConfig {
 		setIfUnexistant("command_ip", "&9IP of {0} is {1}", configuration);
 		setIfUnexistant("illegal_chat_characters", "&cIllegal characters in chat ({0})", configuration);
 
+		// MangoCord start - Antibot System
+		setIfUnexistant("antibot_accounts", "&c&lMangoCord\n\n&cYou have too many accounts! ({0})\n\n&cError? Contact us on discord.gg/VmcKYCmQPn", configuration);
+		setIfUnexistant("antibot_fastchat", "&c&lMangoCord\n\n&cYou are chatting too fast!\n\n&cError? Contact us on discord.gg/VmcKYCmQPn", configuration);
+		setIfUnexistant("antibot_firewall", "&c&lMangoCord\n\n&cYou are blocked from this server!\n\n&cError? Contact us on discord.gg/VmcKYCmQPn", configuration);
+		setIfUnexistant("antibot_nickname", "&c&lMangoCord\n\n&cYour nickname was detected as bot! ({0})\n\n&cError? Contact us on discord.gg/VmcKYCmQPn", configuration);
+		setIfUnexistant("antibot_password", "&c&lMangoCord\n\n&cYour password is used by other players! ({0})\n\n&cError? Contact us on discord.gg/VmcKYCmQPn", configuration);
+		setIfUnexistant("antibot_ratelimit", "&c&lMangoCord\n\n&cYou are connecting too fast! ({0})\n\n&cError? Contact us on discord.gg/VmcKYCmQPn", configuration);
+		setIfUnexistant("antibot_reconnect", "&c&lMangoCord\n\n&cReconnect {0} more times to enter!\n&cRefresh {1} more times to enter!\n\n&cError? Contact us on discord.gg/VmcKYCmQPn", configuration);
+		setIfUnexistant("antibot_country", "&c&lMangoCord\n\n&cYour country {0} is blacklisted!\n\n&cError? Contact us on discord.gg/VmcKYCmQPn", configuration);
+		setIfUnexistant("antibot_proxy", "&c&lMangoCord\n\n&cYou are using a Proxy/VPN! ({0})\n\n&cError? Contact us on discord.gg/VmcKYCmQPn", configuration);
+		setIfUnexistant("antibot_stats", "&c&lMangoCord Antibot Stats\n &7■ Total Pings: &a{0}\n &7■ Total Connections: &b{1}\n\n &7■ Current Pings: &a{2}\n &7■ Current Connections: &b{3}", configuration);
+		
+		setIfUnexistant("mangcord_firewall_help", "&c/mangocord firewall <add/remove> <ip>", configuration);
+		setIfUnexistant("mangcord_firewall_add", "&cThe ip {0} was added to the firewall!", configuration);
+		setIfUnexistant("mangcord_firewall_remove", "&cThe ip {0} was removed from the firewall!", configuration);
+		// MangoCord end - Antibot System
+
 		for (final String key : configuration.getKeys()) {
 			final Object value = configuration.get(key);
 
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/enums/PacketsCheckResult.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/enums/PacketsCheckResult.java
new file mode 100644
index 00000000..285810ea
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/enums/PacketsCheckResult.java
@@ -0,0 +1,5 @@
+package dev.lucianishimiya.mangcord.enums;
+
+public enum PacketsCheckResult {
+    KICK, CANCEL, NONE
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/enums/PacketsViolationReason.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/enums/PacketsViolationReason.java
new file mode 100644
index 00000000..c19c4965
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/enums/PacketsViolationReason.java
@@ -0,0 +1,5 @@
+package dev.lucianishimiya.mangcord.enums;
+
+public enum PacketsViolationReason {
+    SIZE, RATE
+}
diff --git a/mangcord/src/main/java/dev/lucianishimiya/mangcord/utils/ProtocolUtil.java b/mangcord/src/main/java/dev/lucianishimiya/mangcord/utils/ProtocolUtil.java
new file mode 100644
index 00000000..901ab453
--- /dev/null
+++ b/mangcord/src/main/java/dev/lucianishimiya/mangcord/utils/ProtocolUtil.java
@@ -0,0 +1,27 @@
+package dev.lucianishimiya.mangcord.utils;
+
+import io.netty.buffer.ByteBuf;
+
+public class ProtocolUtil {
+    private static int SEGMENT_BITS = 0x7F;
+    private static int CONTINUE_BIT = 0x80;
+
+    public static int readVarInt(ByteBuf byteBuf) {
+        int value = 0;
+        int position = 0;
+        byte currentByte;
+
+        while (byteBuf.isReadable()) {
+            currentByte = byteBuf.readByte();
+            value |= (currentByte & SEGMENT_BITS) << position;
+
+            if ((currentByte & CONTINUE_BIT) == 0) break;
+
+            position += 7;
+
+            if (position >= 32) throw new RuntimeException("VarInt is too big");
+        }
+
+        return value;
+    }
+}
\ No newline at end of file
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java b/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java
index 6316143f..f2c8c58b 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java
@@ -52,11 +52,37 @@ public class MinecraftDecoder extends MessageToMessageDecoder<ByteBuf>
             }
         }
 
+        // MangoCord start - Antibot Packet Check
+        if (prot == protocol.TO_SERVER) {
+            dev.lucianishimiya.mangcord.antibot.PacketsCheck packetsCheck = MangoCord.getInstance().getCheckManager().getPacketsCheck();
+            dev.lucianishimiya.mangcord.enums.PacketsCheckResult result = packetsCheck.check(ctx.channel().remoteAddress(), in);
+
+            switch (result) {
+                case KICK:
+                    packetsCheck.getData(ctx.channel().remoteAddress()).printKick();
+
+                    in.skipBytes(in.readableBytes());
+                    ctx.close();
+                    return;
+                case CANCEL:
+                    packetsCheck.getData(ctx.channel().remoteAddress()).printCancel();
+
+                    in.skipBytes(in.readableBytes());
+                    return;
+                default:
+                    break;
+            }
+        }
+        // MangoCord end - Antibot Packet Check
+
         ByteBuf slice = in.duplicate(); // MangoCord - Duplicate buf instead of Copy
 
         Object packetTypeInfo = null;
         try
         {
+            // MangoCord - Duplicate buf instead of Copy
+            slice = in.duplicate(); // Can't slice this one due to EntityMap :(
+
             // Waterfall start
             if (in.readableBytes() == 0 && !server) {
                 return;
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java b/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java
index c433ac4a..4ee05067 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java
@@ -751,4 +751,8 @@ public enum Protocol
             // Waterfall end
         }
     }
+
+    public DirectionData getToServer() {
+        return TO_SERVER;
+    }
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java b/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java
index 3a802ca4..c23e6856 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java
@@ -5,11 +5,11 @@ import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.CorruptedFrameException;
+
 import java.util.List;
 
 public class Varint21FrameDecoder extends ByteToMessageDecoder
 {
-
     private static boolean DIRECT_WARNING;
 
     @Override
diff --git a/proxy/src/main/java/dev/lucianishimiya/mangcord/commands/MangoCordCommand.java b/proxy/src/main/java/dev/lucianishimiya/mangcord/commands/MangoCordCommand.java
index fb81adee..56bc46eb 100644
--- a/proxy/src/main/java/dev/lucianishimiya/mangcord/commands/MangoCordCommand.java
+++ b/proxy/src/main/java/dev/lucianishimiya/mangcord/commands/MangoCordCommand.java
@@ -4,6 +4,7 @@ import java.util.Collection;
 import java.util.HashSet;
 
 import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.antibot.StatsData;
 import dev.lucianishimiya.mangcord.configuration.MessagesConfiguration;
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.api.CommandSender;
@@ -27,9 +28,7 @@ private final BungeeCord bungeeCord;
 
         if (sender.hasPermission("mangocord.usage")) {
             if (args.length > 0) {
-                final String arg0 = args[0];
-
-                switch (arg0) {
+                switch (args[0]) {
                     case "reload": {
                         // MangoCord - Collect ips from servers
                         final Collection<String> whitelistedAddresses = new HashSet<>();
@@ -43,9 +42,44 @@ private final BungeeCord bungeeCord;
                                 .fromLegacyText(messagesConfiguration.getTranslation("mangcord_reload")));
                         break;
                     }
+                    case "stats": {
+                        StatsData statsData = MangoCord.getInstance().getStatsData();
+                        int totalPings = statsData.getTotalPings();
+                        int totalConnections = statsData.getTotalConnections();
+                        int lastPings = statsData.getLastPings();
+                        int lastConnections = statsData.getLastConnections();
+
+                        sender.sendMessage(TextComponent.fromLegacyText(messagesConfiguration.getTranslation("antibot_stats", totalPings, totalConnections, lastPings, lastConnections)));
+                        break;
+                    }
+                    case "firewall": {
+                        if (args.length > 2) {
+                            String ip = args[2];
+
+                            switch (args[1]) {
+                                case "add": {
+                                    MangoCord.getInstance().getAddressDataManager().getAddressData(ip).firewall("Blacklisted by command");
+                                    sender.sendMessage(TextComponent.fromLegacyText(messagesConfiguration.getTranslation("mangcord_firewall_add", ip)));
+                                    break;
+                                }
+                                case "remove": {
+                                    MangoCord.getInstance().getAddressDataManager().getAddressData(ip).unfirewall();
+                                    sender.sendMessage(TextComponent.fromLegacyText(messagesConfiguration.getTranslation("mangcord_firewall_remove", ip)));
+                                    break;
+                                }
+                                default: {
+                                    sender.sendMessage(TextComponent.fromLegacyText(messagesConfiguration.getTranslation("mangcord_firewall_help")));
+                                    break;
+                                }
+                            }
+                        } else {
+                            sender.sendMessage(TextComponent.fromLegacyText(messagesConfiguration.getTranslation("mangcord_firewall_help")));
+                        }
+
+                        break;
+                    }
                     default: {
-                        sender.sendMessage(TextComponent.fromLegacyText(
-                                messagesConfiguration.getTranslation("mangcord_help", bungeeCord.getVersion())));
+                        sender.sendMessage(TextComponent.fromLegacyText(messagesConfiguration.getTranslation("mangcord_help", bungeeCord.getVersion())));
                         break;
                     }
                 }
diff --git a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
index d4e3ec6f..0d3bed74 100644
--- a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
+++ b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
@@ -533,6 +533,11 @@ public class BungeeCord extends ProxyServer
                     } catch (InterruptedException ignored) {}
         }
 
+        // MangoCord start - Antibot System
+        MangoCord.getInstance().shutdown();
+        getLogger().info( "Shutting down MangoCord linux command thread" );
+        // MangoCord end - Antibot System
+
         getLogger().info( "Thank you and goodbye" );
         // Need to close loggers after last message!
         org.apache.logging.log4j.LogManager.shutdown(); // Waterfall
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
index 5396029c..443e2718 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
@@ -22,8 +22,8 @@ import javax.crypto.SecretKey;
 import javax.crypto.spec.SecretKeySpec;
 
 import dev.lucianishimiya.mangcord.MangoCord;
-
-import dev.lucianishimiya.mangcord.configuration.MangoConfig;
+import dev.lucianishimiya.mangcord.antibot.AddressData;
+import dev.lucianishimiya.mangcord.antibot.CheckManager;
 import dev.lucianishimiya.mangcord.configuration.MangoCordConfiguration;
 import lombok.Getter;
 import lombok.RequiredArgsConstructor;
@@ -422,6 +422,22 @@ public class InitialHandler extends PacketHandler implements PendingConnection
     public void handle(Handshake handshake) throws Exception
     {
         Preconditions.checkState( thisState == State.HANDSHAKE, "Not expecting HANDSHAKE" );
+
+        // MangoCord start - Antibot System
+        // Close and firewall on invalid protocol
+        int protocol = handshake.getRequestedProtocol();
+
+        if (protocol != 1 && protocol != 2) {
+            if ( MangoCord.getInstance().getMangoCordConfiguration().isAntibotRatelimitFirewall() )
+            {
+                MangoCord.getInstance().getAddressDataManager().getAddressData(ch.getChannel().remoteAddress()).firewall("Invalid handshake protocol");
+            }
+
+            ch.close();
+            return;
+        }
+        // MangoCord end - Antibot System
+
         this.handshake = handshake;
         ch.setVersion( handshake.getProtocolVersion() );
         ch.getHandle().pipeline().remove( PipelineUtils.LEGACY_KICKER );
@@ -446,6 +462,48 @@ public class InitialHandler extends PacketHandler implements PendingConnection
 
         this.virtualHost = InetSocketAddress.createUnresolved( handshake.getHost(), handshake.getPort() );
 
+        // MangoCord start - Antibot System
+        SocketAddress remoteAddress = ch.getRemoteAddress();
+        AddressData addressData = MangoCord.getInstance().getAddressDataManager().getAddressData( remoteAddress );
+        CheckManager checkManager = MangoCord.getInstance().getCheckManager();
+
+        if (protocol == 2) {
+            // Set state and protocol to prevent errors
+            thisState = State.USERNAME;
+            ch.setProtocol( Protocol.LOGIN );
+
+            addressData.addConnection();
+
+            if ( checkManager.getRatelimitCheck().check( remoteAddress, protocol ) )
+            {
+                disconnect( bungee.getTranslation( "antibot_ratelimit", addressData.getConnectionsSecond() ) );
+                return;
+            }
+
+            if ( checkManager.getProxyCheck().check( remoteAddress ) )
+            {
+                disconnect( bungee.getTranslation( "antibot_proxy" ) );
+                return;
+            }
+
+            if ( checkManager.getReconnectCheck().check( remoteAddress ) )
+            {
+                disconnect( bungee.getTranslation( "antibot_reconnect", Math.max(0, MangoCord.getInstance().getMangoCordConfiguration().getAntibotReconnectAttempts() - addressData.getTotalConnections() ), Math.max(0, MangoCord.getInstance().getMangoCordConfiguration().getAntibotReconnectPings() - addressData.getTotalPings() ) ) );
+                return;
+            }
+
+            if ( checkManager.getCountryCheck().check( remoteAddress ) )
+            {
+                disconnect( bungee.getTranslation( "antibot_country", addressData.getCountry() ) );
+                return;
+            }
+        }
+
+        // Reset state for event
+        thisState = State.HANDSHAKE;
+        ch.setProtocol( Protocol.HANDSHAKE );
+        // MangoCord end - Antibot System
+
         // MangoCord - Make PlayerHandshakeEvent cancellable
         if (bungee.getPluginManager().callEvent(new PlayerHandshakeEvent(InitialHandler.this, handshake)).isCancelled()) {
             ch.close();
@@ -463,6 +521,17 @@ public class InitialHandler extends PacketHandler implements PendingConnection
                 }
                 thisState = State.STATUS;
                 ch.setProtocol( Protocol.STATUS );
+
+                // MangoCord start - Antibot System
+                addressData.addPing();
+
+                if ( checkManager.getRatelimitCheck().check( remoteAddress, protocol ) )
+                {
+                    ch.close();
+                    return;
+                }
+                // MangoCord end - Antibot System
+
                 break;
             case 2:
                 // Login
@@ -471,6 +540,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
                 {
                     bungee.getLogger().log( Level.INFO, "{0} has connected", this );
                 }
+
                 thisState = State.USERNAME;
                 ch.setProtocol( Protocol.LOGIN );
 
@@ -537,6 +607,26 @@ public class InitialHandler extends PacketHandler implements PendingConnection
             return;
         }
 
+        // MangoCord start - Antibot System
+        CheckManager checkManager = MangoCord.getInstance().getCheckManager();
+        AddressData addressData = MangoCord.getInstance().getAddressDataManager().getAddressData( ch.getRemoteAddress() );
+        String nickname = loginRequest.getData();
+
+        addressData.addNickname( nickname );
+
+        if ( checkManager.getAccountsCheck().check( ch.getRemoteAddress(), nickname ) )
+        {
+            disconnect( bungee.getTranslation( "antibot_accounts", addressData.getNicknames().size() ) );
+            return;
+        }
+
+        if ( checkManager.getNicknameCheck().check( ch.getRemoteAddress() ) )
+        {
+            disconnect( bungee.getTranslation( "antibot_nickname", loginRequest.getData() ) );
+            return;
+        }
+        // MangoCord end - Antibot System
+
         // If offline mode and they are already on, don't allow connect
         // We can just check by UUID here as names are based on UUID
         if ( !isOnlineMode() && bungee.getPlayer( getUniqueId() ) != null )
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
index 86c469ee..a472535a 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
@@ -4,11 +4,15 @@ import com.google.common.base.Preconditions;
 import com.mojang.brigadier.context.StringRange;
 import com.mojang.brigadier.suggestion.Suggestion;
 import com.mojang.brigadier.suggestion.Suggestions;
+
+import dev.lucianishimiya.mangcord.MangoCord;
+import dev.lucianishimiya.mangcord.antibot.CheckManager;
 import io.netty.channel.Channel;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.UUID;
+
 import net.md_5.bungee.BungeeCord;
 import net.md_5.bungee.ServerConnection.KeepAliveData;
 import net.md_5.bungee.UserConnection;
@@ -210,6 +214,23 @@ public class UpstreamBridge extends PacketHandler
             throw CancelSendSignal.INSTANCE;
         }
 
+        // MangoCord start - Antibot System
+        CheckManager checkManager = MangoCord.getInstance().getCheckManager();
+        java.net.SocketAddress socketAddress = con.getCh().getRemoteAddress();
+
+        if ( checkManager.getFastChatCheck().check( socketAddress ) )
+        {
+            con.disconnect( bungee.getTranslation( "antibot_fastchat" ) );
+            throw CancelSendSignal.INSTANCE;
+        }
+
+        if ( checkManager.getPasswordCheck().check( socketAddress, message ) )
+        {
+            con.disconnect( bungee.getTranslation( "antibot_password", checkManager.getPasswordCheck().getRepeatCount() ) );
+            throw CancelSendSignal.INSTANCE;
+        }
+        // MangoCord end - Antibot System
+
         ChatEvent chatEvent = new ChatEvent( con, con.getServer(), message );
         if ( !bungee.getPluginManager().callEvent( chatEvent ).isCancelled() )
         {
diff --git a/proxy/src/main/java/net/md_5/bungee/http/HttpHandler.java b/proxy/src/main/java/net/md_5/bungee/http/HttpHandler.java
index e2911d5e..d853b404 100644
--- a/proxy/src/main/java/net/md_5/bungee/http/HttpHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/http/HttpHandler.java
@@ -8,6 +8,8 @@ import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.LastHttpContent;
 import java.nio.charset.Charset;
+
+import dev.lucianishimiya.mangcord.MangoCord;
 import lombok.RequiredArgsConstructor;
 import net.md_5.bungee.api.Callback;
 
@@ -21,6 +23,14 @@ public class HttpHandler extends SimpleChannelInboundHandler<HttpObject>
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
     {
+        // Mangocord start - Antibot System
+        String reason = cause.getClass().getSimpleName();
+        if (MangoCord.getInstance().getMangoCordConfiguration().getAntibotFirewalledExceptions().contains(reason))
+        {
+            MangoCord.getInstance().getAddressDataManager().getAddressData(ctx.channel().remoteAddress()).firewall(reason);
+        }
+        // Mangocord end - Antibot System
+
         try
         {
             callback.done( null, cause );
diff --git a/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java b/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java
index b3fa4835..6f1d8336 100644
--- a/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java
+++ b/proxy/src/main/java/net/md_5/bungee/netty/ChannelWrapper.java
@@ -154,4 +154,11 @@ public class ChannelWrapper
             pipeline.remove( "decompress" );
         }
     }
+
+    // MangoCord start - Antibot System
+    // Make the channel accessible
+    public Channel getChannel() {
+        return ch;
+    }
+    // MangoCord end - Antibot System
 }
diff --git a/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java b/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java
index 14e3004f..b61ed521 100644
--- a/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java
+++ b/proxy/src/main/java/net/md_5/bungee/netty/HandlerBoss.java
@@ -12,6 +12,7 @@ import io.netty.handler.timeout.ReadTimeoutException;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.util.logging.Level;
+
 import net.md_5.bungee.api.ProxyServer;
 import net.md_5.bungee.connection.CancelSendSignal;
 import net.md_5.bungee.connection.InitialHandler;
@@ -146,6 +147,14 @@ public class HandlerBoss extends ChannelInboundHandlerAdapter
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception
     {
+        // Mangocord start - Antibot System
+        String reason = cause.getClass().getSimpleName();
+        if (MangoCord.getInstance().getMangoCordConfiguration().getAntibotFirewalledExceptions().contains(reason))
+        {
+            MangoCord.getInstance().getAddressDataManager().getAddressData(ctx.channel().remoteAddress()).firewall(reason);
+        }
+        // Mangocord end - Antibot System
+
         if ( ctx.channel().isActive() )
         {
             boolean logExceptions = !( handler instanceof PingHandler );
diff --git a/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java b/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
index 1a5a0e08..9266ba8f 100644
--- a/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
+++ b/proxy/src/main/java/net/md_5/bungee/netty/PipelineUtils.java
@@ -63,6 +63,21 @@ public class PipelineUtils
         {
             SocketAddress remoteAddress = ( ch.remoteAddress() == null ) ? ch.parent().localAddress() : ch.remoteAddress();
 
+            // MangoCord start - Antibot System
+            dev.lucianishimiya.mangcord.MangoCord mangoCord = MangoCord.getInstance();
+            String firewallReason = mangoCord.getAddressDataManager().getAddressData(remoteAddress).getFirewallReason();
+            if ( firewallReason != null )
+            {
+                if ( mangoCord.getMangoCordConfiguration().isAntibotFirewallLog() )
+                {
+                    mangoCord.getLoggerWrapper().log( Level.INFO, "[Mangocord] [{0}] is firewalled from the server. ({1})", new Object[]{ remoteAddress, firewallReason } );
+                }
+
+                ch.close();
+                return;
+            }
+            // MangoCord end - Antibot System
+
             if ( BungeeCord.getInstance().getConnectionThrottle() != null && BungeeCord.getInstance().getConnectionThrottle().throttle( remoteAddress ) )
             {
                 ch.close();
-- 
2.40.1.windows.1

